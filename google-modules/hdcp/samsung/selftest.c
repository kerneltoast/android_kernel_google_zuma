// SPDX-License-Identifier: GPL-2.0-only
/*
 * Copyright (c) 2022 Samsung Electronics Co., Ltd.
 *
 * Samsung DisplayPort driver.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */
#include "selftest.h"

#include <drm/drm_dp_helper.h>
#include <linux/delay.h>
#include <linux/kernel.h>
#include <linux/types.h>

#include <linux/soc/samsung/exynos-smc.h>

#include "auth-control.h"
#include "exynos-hdcp-interface.h"
#include "teeif.h"
#include "hdcp-log.h"

#define HDCP_NO_DIGITAL_OUTPUT (0xff)
#define HDCP_V2_3 (5)

static const uint8_t bcaps[] = { 0x0 };
static const uint8_t rx_caps[] = { 0x02, 0x00, 0x03 };
static const uint8_t cert_rx[] = {
	0x74, 0x5b, 0xb8, 0xbd, 0x04, 0xaf, 0xb5, 0xc5, 0xc6, 0x7b, 0xc5, 0x3a,
	0x34, 0x90, 0xa9, 0x54, 0xc0, 0x8f, 0xb7, 0xeb, 0xa1, 0x54, 0xd2, 0x4f,
	0x22, 0xde, 0x83, 0xf5, 0x03, 0xa6, 0xc6, 0x68, 0x46, 0x9b, 0xc0, 0xb8,
	0xc8, 0x6c, 0xdb, 0x26, 0xf9, 0x3c, 0x49, 0x2f, 0x02, 0xe1, 0x71, 0xdf,
	0x4e, 0xf3, 0x0e, 0xc8, 0xbf, 0x22, 0x9d, 0x04, 0xcf, 0xbf, 0xa9, 0x0d,
	0xff, 0x68, 0xab, 0x05, 0x6f, 0x1f, 0x12, 0x8a, 0x68, 0x62, 0xeb, 0xfe,
	0xc9, 0xea, 0x9f, 0xa7, 0xfb, 0x8c, 0xba, 0xb1, 0xbd, 0x65, 0xac, 0x35,
	0x9c, 0xa0, 0x33, 0xb1, 0xdd, 0xa6, 0x05, 0x36, 0xaf, 0x00, 0xa2, 0x7f,
	0xbc, 0x07, 0xb2, 0xdd, 0xb5, 0xcc, 0x57, 0x5c, 0xdc, 0xc0, 0x95, 0x50,
	0xe5, 0xff, 0x1f, 0x20, 0xdb, 0x59, 0x46, 0xfa, 0x47, 0xc4, 0xed, 0x12,
	0x2e, 0x9e, 0x22, 0xbd, 0x95, 0xa9, 0x85, 0x59, 0xa1, 0x59, 0x3c, 0xc7,
	0x83, 0x01, 0x00, 0x01, 0x10, 0x00, 0x0b, 0xa3, 0x73, 0x77, 0xdd, 0x03,
	0x18, 0x03, 0x8a, 0x91, 0x63, 0x29, 0x1e, 0xa2, 0x95, 0x74, 0x42, 0x90,
	0x78, 0xd0, 0x67, 0x25, 0xb6, 0x32, 0x2f, 0xcc, 0x23, 0x2b, 0xad, 0x21,
	0x39, 0x3d, 0x14, 0xba, 0x37, 0xa3, 0x65, 0x14, 0x6b, 0x9c, 0xcf, 0x61,
	0x20, 0x44, 0xa1, 0x07, 0xbb, 0xcf, 0xc3, 0x4e, 0x95, 0x5b, 0x10, 0xcf,
	0xc7, 0x6f, 0xf1, 0xc3, 0x53, 0x7c, 0x63, 0xa1, 0x8c, 0xb2, 0xe8, 0xab,
	0x2e, 0x96, 0x97, 0xc3, 0x83, 0x99, 0x70, 0xd3, 0xdc, 0x21, 0x41, 0xf6,
	0x0a, 0xd1, 0x1a, 0xee, 0xf4, 0xcc, 0xeb, 0xfb, 0xa6, 0xaa, 0xb6, 0x9a,
	0xaf, 0x1d, 0x16, 0x5e, 0xe2, 0x83, 0xa0, 0x4a, 0x41, 0xf6, 0x7b, 0x07,
	0xbf, 0x47, 0x85, 0x28, 0x6c, 0xa0, 0x77, 0xa6, 0xa3, 0xd7, 0x85, 0xa5,
	0xc4, 0xa7, 0xe7, 0x6e, 0xb5, 0x1f, 0x40, 0x72, 0x97, 0xfe, 0xc4, 0x81,
	0x23, 0xa0, 0xc2, 0x90, 0xb3, 0x49, 0x24, 0xf5, 0xb7, 0x90, 0x2c, 0xbf,
	0xfe, 0x04, 0x2e, 0x00, 0xa9, 0x5f, 0x86, 0x04, 0xca, 0xc5, 0x3a, 0xcc,
	0x26, 0xd9, 0x39, 0x7e, 0xa9, 0x2d, 0x28, 0x6d, 0xc0, 0xcc, 0x6e, 0x81,
	0x9f, 0xb9, 0xb7, 0x11, 0x33, 0x32, 0x23, 0x47, 0x98, 0x43, 0x0d, 0xa5,
	0x1c, 0x59, 0xf3, 0xcd, 0xd2, 0x4a, 0xb7, 0x3e, 0x69, 0xd9, 0x21, 0x53,
	0x9a, 0xf2, 0x6e, 0x77, 0x62, 0xae, 0x50, 0xda, 0x85, 0xc6, 0xaa, 0xc4,
	0xb5, 0x1c, 0xcd, 0xa8, 0xa5, 0xdd, 0x6e, 0x62, 0x73, 0xff, 0x5f, 0x7b,
	0xd7, 0x3c, 0x17, 0xba, 0x47, 0x0c, 0x89, 0x0e, 0x62, 0x79, 0x43, 0x94,
	0xaa, 0xa8, 0x47, 0xf4, 0x4c, 0x38, 0x89, 0xa8, 0x81, 0xad, 0x23, 0x13,
	0x27, 0x0c, 0x17, 0xcf, 0x3d, 0x83, 0x84, 0x57, 0x36, 0xe7, 0x22, 0x26,
	0x2e, 0x76, 0xfd, 0x56, 0x80, 0x83, 0xf6, 0x70, 0xd4, 0x5c, 0x91, 0x48,
	0x84, 0x7b, 0x18, 0xdb, 0x0e, 0x15, 0x3b, 0x49, 0x26, 0x23, 0xe6, 0xa3,
	0xe2, 0xc6, 0x3a, 0x23, 0x57, 0x66, 0xb0, 0x72, 0xb8, 0x12, 0x17, 0x4f,
	0x86, 0xfe, 0x48, 0x0d, 0x53, 0xea, 0xfe, 0x31, 0x48, 0x7d, 0x86, 0xde,
	0xeb, 0x82, 0x86, 0x1e, 0x62, 0x03, 0x98, 0x59, 0x00, 0x37, 0xeb, 0x61,
	0xe9, 0xf9, 0x7a, 0x40, 0x78, 0x1c, 0xba, 0xbc, 0x0b, 0x88, 0xfb, 0xfd,
	0x9d, 0xd5, 0x01, 0x11, 0x94, 0xe0, 0x35, 0xbe, 0x33, 0xe8, 0xe5, 0x36,
	0xfb, 0x9c, 0x45, 0xcb, 0x75, 0xaf, 0xd6, 0x35, 0xff, 0x78, 0x92, 0x7f,
	0xa1, 0x7c, 0xa8, 0xfc, 0xb7, 0xf7, 0xa8, 0x52, 0xa9, 0xc6, 0x84, 0x72,
	0x3d, 0x1c, 0xc9, 0xdf, 0x35, 0xc6, 0xe6, 0x00, 0xe1, 0x48, 0x72, 0xce,
	0x83, 0x1b, 0xcc, 0xf8, 0x33, 0x2d, 0x4f, 0x98, 0x75, 0x00, 0x3c, 0x41,
	0xdf, 0x7a, 0xed, 0x38, 0x53, 0xb1, 0x3b, 0xa0, 0xbe, 0xde, 0x0c, 0x46,
	0xa9, 0x91, 0x02, 0x00, 0x03 };
static const uint8_t Hprime[] = {
	0x2e, 0xf5, 0xed, 0xf8, 0x7f, 0xd8, 0xa3, 0xd0, 0xf4, 0xa9, 0xd8, 0xac,
	0x3a, 0xd0, 0xb4, 0x56, 0x2e, 0x32, 0x19, 0x11, 0x41, 0x16, 0xf1, 0xef,
	0x0f, 0x02, 0x3d, 0x3a, 0x78, 0xe2, 0x2a, 0xc6 };
static const uint8_t Ekh_km_r[] = { 0xb8, 0x9f, 0xf9, 0x72, 0x6a, 0x6f, 0x2c, 0x1e,
			      0x29, 0xb6, 0x44, 0x8d, 0xdc, 0xa3, 0x10, 0xbd };
static const uint8_t Lprime[] = {
	0xbc, 0x20, 0x92, 0x33, 0x54, 0x91, 0xc1, 0x9e, 0xa4, 0xde, 0x8b, 0x30,
	0x49, 0xc2, 0x06, 0x6a, 0xd8, 0x11, 0xa2, 0x2a, 0xb1, 0x46, 0xdf, 0x74,
	0x58, 0x47, 0x05, 0xa8, 0xb7, 0x67, 0xfb, 0xdd };
static const uint8_t RxInfo[] = { 0x02, 0x31 };
static const uint8_t seq_num_V[] = { 0x0, 0x0, 0x0 };
static const uint8_t Vprime[] = { 0xbc, 0xcc, 0x7d, 0x16, 0xe6, 0xbc, 0xb9, 0x02,
			    0x60, 0x08, 0x1d, 0xf7, 0x4a, 0xb4, 0x5c, 0x8a };
static const uint8_t Rec_ID_list[] = { 0x47, 0x8e, 0x71, 0xe2, 0x0f,
				 0x35, 0x79, 0x6a, 0x17, 0x0e,
				 0x74, 0xe8, 0x53, 0x97, 0xa2 };
static const uint8_t Mprime[] = {
	0xdd, 0x26, 0xe9, 0x52, 0x6e, 0x0e, 0x1d, 0x69, 0xc8, 0x84, 0xe4, 0xcc,
	0xc8, 0x09, 0xaa, 0xc7, 0x71, 0xe9, 0x97, 0xb5, 0x61, 0x89, 0x09, 0x6e,
	0x4d, 0x94, 0x24, 0xc2, 0x1b, 0x64, 0x58, 0xc6 };
static const uint8_t RxStatus[] = { 0x7 };

static int pdp_dpcd_read_for_hdcp22_emu(u32 address, u32 length, u8 *data)
{
	int ret = 0;

	const size_t banks[] = { DP_AUX_HDCP_BCAPS,
		DP_HDCP_2_2_REG_RX_CAPS_OFFSET, DP_HDCP_2_2_REG_CERT_RX_OFFSET,
		DP_HDCP_2_2_REG_HPRIME_OFFSET, DP_HDCP_2_2_REG_EKH_KM_RD_OFFSET,
		DP_HDCP_2_2_REG_LPRIME_OFFSET, DP_HDCP_2_2_REG_RXINFO_OFFSET,
		DP_HDCP_2_2_REG_SEQ_NUM_V_OFFSET, DP_HDCP_2_2_REG_VPRIME_OFFSET,
		DP_HDCP_2_2_REG_RECV_ID_LIST_OFFSET, DP_HDCP_2_2_REG_MPRIME_OFFSET,
		DP_HDCP_2_2_REG_RXSTATUS_OFFSET };
	const size_t banks_size[] = { sizeof(bcaps),
		sizeof(rx_caps), sizeof(cert_rx), sizeof(Hprime),
		sizeof(Ekh_km_r), sizeof(Lprime), sizeof(RxInfo),
		sizeof(seq_num_V), sizeof(Vprime), sizeof(Rec_ID_list),
		sizeof(Mprime), sizeof(RxStatus) };
	const uint8_t *bank_ptr[] = {
		bcaps, rx_caps, cert_rx, Hprime, Ekh_km_r, Lprime, RxInfo,
		seq_num_V, Vprime, Rec_ID_list, Mprime, RxStatus };
	size_t bank_idx;
	size_t bank_offset = 0;

	for (bank_idx = ARRAY_SIZE(banks) - 1; bank_idx >= 0; --bank_idx) {
		if (address >= banks[bank_idx]) {
			bank_offset = address - banks[bank_idx];
			break;
		}
	}

	if (bank_offset + length > banks_size[bank_idx]) {
		hdcp_err("read impossible for DPCD[%x] with length(%u) as it "
			 "exceeds bank size (%zu) for bank(%zu)\n",
			 address, length, banks_size[bank_idx], bank_idx);
		return -EIO;
	}

	memcpy(data, bank_ptr[bank_idx] + bank_offset, length);
	return ret;
}

static const uint8_t Rtx[] = {0x18, 0xfa, 0xe4, 0x20, 0x6a, 0xfb, 0x51, 0x49};
static const uint8_t TxCaps[] = {0x02, 0x00, 0x00};
static const uint8_t Ekpub_km[] = {
	0x9b, 0x9f, 0x80, 0x19, 0xad, 0x0e, 0xa2, 0xf0, 0xdd, 0xa0, 0x29, 0x33,
	0xd9, 0x6d, 0x1c, 0x77, 0x31, 0x37, 0x57, 0xe0, 0xe5, 0xb2, 0xbd, 0xdd,
	0x36, 0x3e, 0x38, 0x4e, 0x7d, 0x40, 0x78, 0x66, 0x97, 0x7a, 0x4c, 0xce,
	0xc5, 0xc7, 0x5d, 0x01, 0x57, 0x26, 0xcc, 0xa2, 0xf6, 0xde, 0x34, 0xdd,
	0x29, 0xbe, 0x5e, 0x31, 0xe8, 0xf1, 0x34, 0xe8, 0x1a, 0x63, 0xa3, 0x6d,
	0x46, 0xdc, 0x0a, 0x06, 0x08, 0x99, 0x9d, 0xdb, 0x3c, 0xa2, 0x9c, 0x04,
	0xdd, 0x4e, 0xd9, 0x02, 0x7d, 0x20, 0x54, 0xec, 0xca, 0x86, 0x42, 0x1b,
	0x18, 0xda, 0x30, 0x9c, 0xc4, 0xcb, 0xac, 0xb4, 0x54, 0xde, 0x84, 0x68,
	0x71, 0x53, 0x6d, 0x92, 0x17, 0xca, 0x08, 0x8a, 0x7a, 0xf9, 0x98, 0x9a,
	0xb6, 0x7b, 0x22, 0x92, 0xac, 0x7d, 0x0d, 0x6b, 0xd6, 0x7f, 0x31, 0xab,
	0xf0, 0x10, 0xc5, 0x2a, 0x0f, 0x6d, 0x27, 0xa0 };
static const uint8_t Ekh_km_w[] = {
	0xb8, 0x9f, 0xf9, 0x72, 0x6a, 0x6f, 0x2c, 0x1e, 0x29, 0xb6, 0x44, 0x8d,
	0xdc, 0xa3, 0x10, 0xbd };
static const uint8_t m[] = {
	0x18, 0xfa, 0xe4, 0x20, 0x6a, 0xfb, 0x51, 0x49, 0x3b, 0xa0, 0xbe, 0xde,
	0x0c, 0x46, 0xa9, 0x91 };
static const uint8_t rn[] = { 0x32, 0x75, 0x3e, 0xa8, 0x78, 0xa6, 0x38, 0x1c };
static const uint8_t Edkey_ks[] = {
	0x4c, 0x32, 0x47, 0x12, 0xc4, 0xbe, 0xc6, 0x69, 0x0a, 0xc2, 0x19, 0x64,
	0xde, 0x91, 0xf1, 0x83 };
static const uint8_t riv[] = { 0x40, 0x2b, 0x6b, 0x43, 0xc5, 0xe8, 0x86, 0xd8 };
static const uint8_t V[] = { 0x63, 0x6d, 0xc5, 0x08, 0x4d, 0x6c, 0xb1, 0x0e,
			     0x93, 0xa5, 0x28, 0x67, 0x0f, 0x34, 0x1f, 0x88 };
static const uint8_t seq_num_M[] = { 0x0, 0x0, 0x0 };
static const uint8_t k[] = { 0x0, 0x1 };
static const uint8_t stream_IDtype[] = { 0x0, 0x1 };

static int pdp_dpcd_write_for_hdcp22_emu(u32 address, u32 length, u8 *data)
{
	size_t i;
	const size_t banks[] = {
		DP_HDCP_2_2_REG_RTX_OFFSET, DP_HDCP_2_2_REG_TXCAPS_OFFSET,
		DP_HDCP_2_2_REG_EKPUB_KM_OFFSET, DP_HDCP_2_2_REG_EKH_KM_WR_OFFSET,
		DP_HDCP_2_2_REG_M_OFFSET, DP_HDCP_2_2_REG_RN_OFFSET,
		DP_HDCP_2_2_REG_EDKEY_KS_OFFSET, DP_HDCP_2_2_REG_RIV_OFFSET,
		DP_HDCP_2_2_REG_V_OFFSET, DP_HDCP_2_2_REG_SEQ_NUM_M_OFFSET,
		DP_HDCP_2_2_REG_K_OFFSET, DP_HDCP_2_2_REG_STREAM_ID_TYPE_OFFSET,
		DP_HDCP_2_2_REG_STREAM_TYPE_OFFSET };
	const size_t banks_size[] = {
		sizeof(Rtx), sizeof(TxCaps), sizeof(Ekpub_km), sizeof(Ekh_km_w),
		sizeof(m), sizeof(rn), sizeof(Edkey_ks), sizeof(riv), sizeof(V),
		sizeof(seq_num_M), sizeof(k), sizeof(stream_IDtype), 0 };
	const uint8_t *bank_ptr[] = {
		Rtx, TxCaps, Ekpub_km, Ekh_km_w, m, rn, Edkey_ks, riv, V,
		seq_num_M, k, stream_IDtype, NULL };
	size_t bank_idx;
	size_t bank_offset = 0;

	for (bank_idx = ARRAY_SIZE(banks) - 1; bank_idx >= 0; --bank_idx) {
		if (address >= banks[bank_idx]) {
			bank_offset = address - banks[bank_idx];
			break;
		}
	}

	if (bank_offset + length > banks_size[bank_idx]) {
		hdcp_err("write impossible for DPCD[%x] with length(%u) as it "
			 "exceeds bank size (%zu) for bank(%zu)\n",
			 address, length, banks_size[bank_idx], bank_idx);
		return -EIO;
	}

	if (memcmp(data, bank_ptr[bank_idx] + bank_offset, length) != 0) {
		hdcp_err("unexpected write for DPCD[%08x] with length(%u) to"
			 "bank(%zu)\n", address, length, bank_idx);
		for (i = 0; i < length; ++i) {
			hdcp_err("%02x %02x\n", *(data + i),
				 *(bank_ptr[bank_idx] + bank_offset + i));
		}
		return -EIO;
	}

	return 0;
}

static void pdp_hdcp22_enable_emu(u32 en)
{
	return;
}

static int dp_hdcp_protocol_self_test_internal(void) {
	size_t i;
	int rc, version;

	hdcp_dplink_connect_state(DP_CONNECT);
	msleep(HDCP_SCHEDULE_DELAY_MSEC);

	version = -1;
	for (i = 0; i < 50; ++i) {
		rc = hdcp_tee_check_protection(&version);
		if (rc) {
			hdcp_err("checking protection failed: %d", rc);
			return rc;
		}
		if (version == HDCP_V2_3) {
			hdcp_info("SUCCESS selftest\n");
			return 0;
		}
		msleep(100);
	}

	hdcp_err("FAIL selftest: HDCP_VERSION(%d)\n", version);
	return -EIO;
}

int hdcp_protocol_self_test(void) {
	int rc;

	rc = exynos_smc(SMC_HDCP_NOTIFY_INTR_NUM, 1, 0, 0);
	if (!rc) {
		hdcp_err("expected direct smc call to fail\n");
		return rc;
	}

	dp_register_func_for_hdcp22(pdp_hdcp22_enable_emu,
				    pdp_dpcd_read_for_hdcp22_emu,
				    pdp_dpcd_write_for_hdcp22_emu);

	rc = hdcp_tee_set_test_mode(true);
	if (rc) {
		hdcp_err("setting test mode failed: %d", rc);
		return rc;
	}
	rc = dp_hdcp_protocol_self_test_internal();
	hdcp_dplink_connect_state(DP_DISCONNECT);
	hdcp_tee_set_test_mode(false);

	return rc;
}
